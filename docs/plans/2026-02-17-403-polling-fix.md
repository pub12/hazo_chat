# 403 Polling Loop Fix — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Stop the useChatMessages hook from retrying on 403 permission errors, expose a `'forbidden'` polling status and `error_info` to consumers, and downgrade server-side membership log from error to warn.

**Architecture:** Add a `ChatApiError` class that carries HTTP status and error_code from the API response. The fetch wrapper throws this instead of a bare Error. Both `load_initial` and `schedule_next_poll` catch blocks detect permission errors and stop retrying immediately.

**Tech Stack:** TypeScript, React hooks. No test framework exists in this project — verification is via `npm run build` (TypeScript compilation).

---

### Task 1: Add ErrorInfo type and update PollingStatus + UseChatMessagesReturn

**Files:**
- Modify: `src/types/index.ts:474` (PollingStatus type)
- Modify: `src/types/index.ts:583-595` (UseChatMessagesReturn interface)

**Step 1: Add 'forbidden' to PollingStatus**

In `src/types/index.ts`, change line 474:

```typescript
// Before:
export type PollingStatus = 'connected' | 'reconnecting' | 'error';

// After:
export type PollingStatus = 'connected' | 'reconnecting' | 'error' | 'forbidden';
```

**Step 2: Add ErrorInfo interface**

Add directly above `UseChatMessagesReturn` (before line 583):

```typescript
/**
 * Error information exposed by useChatMessages when polling encounters
 * a non-retryable error (e.g., 403 FORBIDDEN).
 */
export interface ErrorInfo {
  code: string;
  message: string;
}
```

**Step 3: Add error_info to UseChatMessagesReturn**

In `UseChatMessagesReturn`, add after the `polling_status` field:

```typescript
error_info: ErrorInfo | null;
```

**Step 4: Verify build**

Run: `npm run build`
Expected: Compilation error in `use_chat_messages.ts` because hook return doesn't include `error_info` yet. This confirms the type is enforced.

**Step 5: Commit**

```bash
git add src/types/index.ts
git commit -m "feat(types): add ErrorInfo type, 'forbidden' polling status, error_info to hook return"
```

---

### Task 2: Add ChatApiError class and update fetch_messages_from_api

**Files:**
- Modify: `src/hooks/use_chat_messages.ts:346-404` (fetch_messages_from_api)

**Step 1: Add ChatApiError class at module scope**

Add after the existing constants block (after line 49, before the hook parameters section), inside the same file:

```typescript
// ============================================================================
// Custom Error for API responses
// ============================================================================

class ChatApiError extends Error {
  status: number;
  error_code: string | undefined;

  constructor(status: number, message: string, error_code?: string) {
    super(message);
    this.name = 'ChatApiError';
    this.status = status;
    this.error_code = error_code;
  }
}

/** Check if an error is a permission/auth error that should not be retried */
function is_permission_error(err: unknown): boolean {
  return err instanceof ChatApiError && (err.status === 403 || err.status === 401);
}
```

**Step 2: Update fetch_messages_from_api error throwing**

Replace the current error handling in fetch_messages_from_api (lines 382-384):

```typescript
// Before:
if (!response.ok) {
  throw new Error(`HTTP ${response.status}`);
}

// After:
if (!response.ok) {
  let error_code: string | undefined;
  let error_message = `HTTP ${response.status}`;
  try {
    const error_data = await response.json();
    error_code = error_data.error_code;
    if (error_data.error) error_message = error_data.error;
  } catch {
    /* response body not parseable — use defaults */
  }
  throw new ChatApiError(response.status, error_message, error_code);
}
```

**Step 3: Verify build**

Run: `npm run build`
Expected: Still fails because hook return doesn't include `error_info` — that's expected. The ChatApiError code itself should compile cleanly.

**Step 4: Commit**

```bash
git add src/hooks/use_chat_messages.ts
git commit -m "feat(hook): add ChatApiError class and structured error throwing in fetch"
```

---

### Task 3: Add error_info state, update load_initial and schedule_next_poll catch blocks

**Files:**
- Modify: `src/hooks/use_chat_messages.ts`

**Step 1: Add error_info state**

Add after line 148 (`const [polling_status, ...`):

```typescript
const [error_info, set_error_info] = useState<ErrorInfo | null>(null);
```

Also add the import for `ErrorInfo` to the existing type imports from `'../types/index.js'` (line 20-28):

```typescript
import type {
  ChatMessage,
  ChatMessageDB,
  CreateMessagePayload,
  HazoUserProfile,
  UseChatMessagesReturn,
  PollingStatus,
  RealtimeMode,
  ClientLogger,
  ErrorInfo,
} from '../types/index.js';
```

**Step 2: Update load_initial catch block**

Replace the catch block in `load_initial` (lines 451-455):

```typescript
// Before:
} catch (err) {
  if (is_mounted_ref.current) {
    set_error('Failed to load messages');
    set_polling_status('error');
  }
}

// After:
} catch (err) {
  if (is_mounted_ref.current) {
    if (is_permission_error(err)) {
      const api_err = err as ChatApiError;
      set_polling_status('forbidden');
      set_error_info({ code: api_err.error_code || 'FORBIDDEN', message: api_err.message });
      set_error('Access denied');
    } else {
      set_error('Failed to load messages');
      set_polling_status('error');
    }
  }
}
```

**Step 3: Update schedule_next_poll catch block and finally block**

The current structure (lines 515-576) is:

```typescript
polling_timer_ref.current = setTimeout(async () => {
  // ...
  try { ... }
  catch (err) { ... }
  finally {
    is_polling_ref.current = false;
    if (is_mounted_ref.current && config.realtime_mode === 'polling') {
      schedule_next_poll();
    }
  }
}, delay);
```

Replace the entire `try/catch/finally` inside the setTimeout callback with:

```typescript
let should_continue_polling = true;

try {
  // Use ref to get latest messages without causing callback re-creation
  const current_messages = messages_ref.current;
  const latest_message = current_messages[current_messages.length - 1];
  const user_id = current_user_id_ref.current;

  const result = await fetch_messages_from_api(
    latest_message
      ? { cursor: latest_message.created_at, direction: 'newer', limit: 50 }
      : undefined
  );

  if (result.messages.length > 0 && is_mounted_ref.current && user_id) {
    const transformed = await transform_messages(result.messages, user_id);

    set_messages((prev) => {
      // Merge new messages, avoiding duplicates
      const existing_ids = new Set(prev.map((m) => m.id));
      const new_messages = transformed.filter((m) => !existing_ids.has(m.id));

      if (new_messages.length > 0) {
        const combined = [...prev, ...new_messages];
        return combined.sort(
          (a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
        );
      }
      return prev;
    });
  }

  // Reset retry count on success
  retry_count_ref.current = 0;
  if (is_mounted_ref.current) {
    set_polling_status('connected');
  }
} catch (err) {
  if (is_permission_error(err)) {
    // Permission errors will never self-resolve — stop polling immediately
    should_continue_polling = false;
    if (is_mounted_ref.current) {
      const api_err = err as ChatApiError;
      set_polling_status('forbidden');
      set_error_info({ code: api_err.error_code || 'FORBIDDEN', message: api_err.message });
    }
  } else {
    // Network/transient errors — retry with backoff
    retry_count_ref.current += 1;

    if (is_mounted_ref.current) {
      if (retry_count_ref.current >= MAX_RETRY_ATTEMPTS) {
        // Only log error when max retries reached
        logger.error('[useChatMessages] Polling failed after max retries', { error: err });
        set_polling_status('error');
      } else {
        set_polling_status('reconnecting');
      }
    }
  }
} finally {
  is_polling_ref.current = false;
  // Schedule next poll only for retryable errors
  if (should_continue_polling && is_mounted_ref.current && config.realtime_mode === 'polling') {
    schedule_next_poll();
  }
}
```

**Step 4: Update hook return to include error_info**

Replace the return block (lines 841-853):

```typescript
return {
  messages,
  is_loading,
  is_loading_more,
  has_more,
  error,
  polling_status,
  error_info,
  load_more,
  send_message,
  delete_message,
  mark_as_read,
  refresh
};
```

**Step 5: Verify build**

Run: `npm run build`
Expected: PASS — all types align now.

**Step 6: Commit**

```bash
git add src/hooks/use_chat_messages.ts
git commit -m "feat(hook): handle 403 as non-retryable, expose error_info to consumers"
```

---

### Task 4: Update connection status indicator in HazoChat component

**Files:**
- Modify: `src/components/hazo_chat/hazo_chat.tsx:142-162` (destructure error_info from hook)
- Modify: `src/components/hazo_chat/hazo_chat.tsx:547-561` (status indicator JSX)

**Step 1: Destructure error_info from useChatMessages**

Update the hook destructuring (around line 142):

```typescript
const {
  messages,
  is_loading: is_loading_messages,
  has_more,
  load_more,
  send_message,
  delete_message,
  mark_as_read,
  polling_status,
  error_info,
  refresh: refresh_messages
} = useChatMessages({
  chat_group_id,
  logger,
  reference_id,
  reference_type,
  api_base_url,
  realtime_mode,
  polling_interval,
  messages_per_page,
  log_polling
});
```

**Step 2: Update the connection status indicator**

Replace the status indicator JSX (lines 547-561):

```typescript
{/* Connection status indicator */}
{polling_status !== 'connected' && (
  <div
    className={cn(
      'cls_connection_status',
      'absolute bottom-20 left-1/2 -translate-x-1/2',
      'px-3 py-1.5 rounded-full text-xs font-medium z-10',
      polling_status === 'reconnecting'
        ? 'bg-yellow-100 text-yellow-800'
        : polling_status === 'forbidden'
          ? 'bg-orange-100 text-orange-800'
          : 'bg-red-100 text-red-800'
    )}
  >
    {polling_status === 'reconnecting'
      ? 'Reconnecting...'
      : polling_status === 'forbidden'
        ? 'Access denied'
        : 'Connection error'}
  </div>
)}
```

**Step 3: Verify build**

Run: `npm run build`
Expected: PASS

**Step 4: Commit**

```bash
git add src/components/hazo_chat/hazo_chat.tsx
git commit -m "feat(ui): show 'Access denied' status for forbidden polling state"
```

---

### Task 5: Downgrade server-side membership log from error to warn

**Files:**
- Modify: `src/api/messages.ts:185` (GET membership check)
- Modify: `src/api/messages.ts:362` (POST membership check)

**Step 1: Change GET handler membership log**

Line 185, change `logger.error` to `logger.warn`:

```typescript
// Before:
logger.error('[hazo_chat/messages GET] User is not a member of chat group:', {

// After:
logger.warn('[hazo_chat/messages GET] User is not a member of chat group:', {
```

**Step 2: Change POST handler membership log**

Line 362, change `logger.error` to `logger.warn`:

```typescript
// Before:
logger.error('[hazo_chat/messages POST] User is not a member of chat group:', {

// After:
logger.warn('[hazo_chat/messages POST] User is not a member of chat group:', {
```

**Step 3: Verify build**

Run: `npm run build`
Expected: PASS

**Step 4: Commit**

```bash
git add src/api/messages.ts
git commit -m "fix(api): downgrade membership check log from error to warn"
```

---

### Task 6: Final verification — clean build and test-app build

**Step 1: Clean build**

Run: `npm run clean && npm run build`
Expected: PASS with zero errors.

**Step 2: Test-app build (if available)**

Run: `npm run build:test-app`
Expected: PASS — test-app doesn't reference error_info yet, so no breakage.

**Step 3: Verify exported types**

Check that `ErrorInfo` is exported from the package entry point. Since `src/types/index.ts` is re-exported via `src/index.ts` (`export * from './types/index.js'`), `ErrorInfo` will be automatically available to consumers as:

```typescript
import type { ErrorInfo } from 'hazo_chat';
```

No extra export wiring needed.

**Step 4: Commit if any fixups were needed**

Only commit if Steps 1-2 revealed issues. Otherwise, no commit.
